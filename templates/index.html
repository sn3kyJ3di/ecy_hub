<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ECY Hub</title>
  <style>
    /* Reset some default styles */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    /* Top Banner Styles */
    .top-banner {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(51, 51, 51, 0.9);
      color: white;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      text-align: center;
    }

    .top-banner h1 {
      margin: 0;
      font-size: 24px;
    }

    .top-banner h2 {
      margin: 0;
      font-size: 16px;
    }

    /* Background Styles */
    .background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(26, 26, 63, .8), rgba(26, 26, 63, .8)), url('static/images/v3g6yjn9sqcbdgwvnzfz.png') no-repeat center center fixed;
      background-size: cover;
      z-index: -1;
    }

    svg {
      position: absolute;
      top: 80px;
      left: 0;
      width: 100%;
      height: calc(100% - 80px);
    }

    /* Node and Link Styles */
    .node circle {
      stroke: white;
      stroke-width: 1.5px;
    }

    .link-visible {
      fill: none;
      stroke: yellow;
      stroke-width: 3px;
      pointer-events: none;
    }

    .link-hover {
      fill: none;
      stroke: transparent;
      stroke-width: 20px;
      cursor: pointer;
    }

    .tooltip {
      position: absolute;
      text-align: center;
      width: auto;
      padding: 10px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
    }

    text {
      fill: black;
    }

    /* Legend Styles */
    .legend {
      background: #333;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      margin-bottom: 20px;
    }

    .legend-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .legend-container h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 18px;
      font-weight: bold;
      color: white;
      align-self: flex-start;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .legend-items-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .legend-color {
      width: 30px;
      height: 30px;
      margin-right: 10px;
      border-radius: 50%;
    }

    .legend-item input[type="checkbox"] {
      margin-right: 10px;
    }

    .legend-item span {
      vertical-align: middle;
    }

    .legend-item:first-child {
      padding-left: 28px;
    }

    .group-circle {
      fill: none;
      stroke: lightblue;
      stroke-width: 2px;
      stroke-dasharray: 5, 5;
    }

    /* Side Panel Styles */
    .side-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 400px;
      height: 100%;
      background: rgba(51, 51, 51, 0.9);
      color: white;
      padding: 20px 40px 20px 20px;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s ease-out;
      transform: translateX(-100%);
      z-index: 1000;
      overflow-y: auto;
    }

    .side-panel.show {
      transform: translateX(0);
    }

    .side-panel-content {
      opacity: 1;
      transition: opacity 0.3s ease-out;
    }

    .side-panel.collapsed .side-panel-content {
      opacity: 0;
      pointer-events: none;
    }

    .side-panel-toggle {
      position: absolute;
      top: 20px;
      right: 0px;
      width: 20px;
      height: 60px;
      background: rgba(51, 51, 51, 0.9);
      border: none;
      color: white;
      cursor: pointer;
      z-index: 1001;
      outline: none;
    }

    .side-panel-toggle:before {
      content: "◀";
    }

    .side-panel.collapsed .toggle-button:before {
      content: "▶";
    }

    /* Dropdown Styles */
    .dropdown-select {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
    }

    .close-button {
      float: right;
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      padding: 5px 10px;
      margin: -10px -10px 0 0;
    }

    /* Node Visibility Styles */
    .node-hidden {
      visibility: hidden;
    }

    .link-visible.link-clicked {
      stroke: red !important;
    }

    .node-faded {
      opacity: 0.2;
    }

    /* Form Container Styles */
    .form-container {
      width: 100%;
    }

    .form-container label {
      margin-bottom: 5px;
      cursor: pointer;
      width: 100%;
      text-align: left;
    }

    .form-container input {
      margin-bottom: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    .form-container button {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin-bottom: 10px;
    }

    .dropdown-container {
      width: 100%;
      margin-top: 0px;
    }

    .tooltip-text {
      visibility: hidden;
      background-color: #333;
      color: white;
      text-align: center;
      padding: 5px;
      border-radius: 5px;
      position: absolute;
      z-index: 1;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      white-space: wrap;
      margin-top: 10px;
    }

    .form-container label:hover .tooltip-text {
      visibility: visible;
    }

    .node-tooltip {
      position: absolute;
      text-align: center;
      width: auto;
      padding: 10px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
      color: black;
    }

    .right-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 250px;
      height: 100%;
      background: rgba(51, 51, 51, 0.9);
      color: white;
      padding: 20px;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s ease-out;
      z-index: 1000;
    }

    .right-panel-content {
      opacity: 1;
      transition: opacity 0.3s ease-out;
    }

    .right-panel.collapsed {
      transform: translateX(100%);
    }

    .right-panel.collapsed .right-panel-content {
      opacity: 0;
    }

    .toggle-button {
      position: absolute;
      top: 20px;
      left: -20px;
      width: 20px;
      height: 60px;
      background: rgba(51, 51, 51, 0.9);
      border: none;
      color: white;
      cursor: pointer;
      outline: none;
    }

    .toggle-button:before {
      content: "◀";
    }

    .right-panel.collapsed .toggle-button:before {
      content: "▶";
    }

    .link-hidden {
      display: none;
      pointer-events: none;
    }

    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(26, 26, 63, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000; /* Higher than other elements */
    }

    .spinner {
      border: 12px solid #f3f3f3; /* Light grey */
      border-top: 12px solid #3CCFFF; /* Blue */
      border-radius: 50%;
      width: 80px;
      height: 80px;
      animation: spin 1.5s linear infinite;
    }

    .loading-text {
      margin-top: 20px;
      font-size: 18px;
      color: white;
    }

    /* Spinner Animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .failed-ips-list {
      list-style-type: none;
      padding-left: 0;
      max-height: 150px;
      overflow-y: auto;
    }

    .failed-ips-list li {
      background-color: #ff4d4d;
      color: white;
      margin-bottom: 10px;
      border-radius: 4px;
    }

    .clear-failed-ips {
      background-color: #ff4d4d;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 0px;
    }

    .clear-failed-ips:hover {
      background-color: #e60000;
    }

    /* The Modal (background) */
    .modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 3000; /* Sit on top */
      padding-top: 100px; /* Location of the box */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
      transition: opacity 0.3s ease;
      opacity: 0;
    }

    .modal.show {
      display: block;
      opacity: 1;
    }

    /* Modal Content */
    .modal-content {
      background-color: #fefefe;
      margin: auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
      color: black;
    }

    /* The Close Button */
    .modal-content .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .modal-content .close:hover,
    .modal-content .close:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    .modal-failed-ips-list {
      list-style-type: none;
      padding-left: 0;
      max-height: 300px; /* Limit height for scrollability */
      overflow-y: auto; /* Enable vertical scrolling */
    }

    .modal-failed-ips-list li {
      background-color: #ff4d4d; /* Red background for failed IPs */
      color: white;
      margin-bottom: 0px;
      padding: 5px 5px;
      border-radius: 4px;
    }

    .checkbox-container {
      display: flex;
      align-items: flex-start;
      gap: 0px; /* Defines a 5-pixel gap between checkbox and label */
      margin-bottom: 0px; /* Maintains space below the checkbox-container */
      width: 100%; /* Ensures the container spans the full width */
    }
    
    .checkbox-container input[type="checkbox"] {
      margin-right: 0px;
      width: 10%;
    }

    .checkbox-container label {
      margin-left: 0px; /* Space between the checkbox and the label */
      white-space: nowrap; /* Prevent the text from wrapping */
      font-size: 16px; /* Adjust as needed */
    }

    .configuration-container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 5px;            
      padding: 5px; 
    }

    .configuration-container form {
      width: 100%;
      margin-bottom: 0px; /* Removes default bottom margin */
    }

    .configuration-container form button {
      margin-top: 0px; /* Adds space above buttons in forms */
    }

    .configuration-container label {
      margin-bottom: 5px; /* Maintains consistent spacing below labels */
      cursor: pointer;
      width: 100%;
      text-align: left;
    }

    .configuration-container input {
      margin-bottom: 5px;
      width: 100%;
      box-sizing: border-box;
    }

    /* Common styles for all action buttons */
    .action-button {
      display: flex;                    /* Enables Flexbox */
      align-items: center;              /* Vertically centers the text */
      justify-content: center;
      background-color: #333;          /* Default background color */
      color: white;                    /* Text color */
      border: 1px solid white;         /* Border styling */
      padding: 0px 20px;              /* Consistent padding */
      font-size: 12px;                 /* Consistent font size */
      cursor: pointer;                 /* Pointer cursor on hover */
      border-radius: 4px;              /* Rounded corners */
      width: 100%;                     /* Full width of the container */
      box-sizing: border-box;          /* Include padding and border in total width and height */
      text-align: center;              /* Center the text */
      transition: background-color 0.3s ease; /* Smooth transition on hover */
      line-height: 20px;
      height: 20px;                    /* Increased height for consistency */
      overflow: hidden;                /* Hide overflow text */
      text-overflow: ellipsis;         /* Add ellipsis for overflow text */
      white-space: nowrap;             /* Prevent text wrapping */
      margin: 0;                  /* Center buttons if max-width is set */
    }

    .action-button:hover {
      background-color: #555;          /* Darker background on hover */
    }

    .action-button:active {
      background-color: #111;          /* Even darker background when clicked */
    }

    /* Specific button styles */

    /* Clear Failed IPs Button - Red background to indicate action */
    .clear-failed-ips {
      background-color: #ff4d4d;       /* Specific background color */
      border: none;                     /* Remove border if desired */
    }

    /* View Failed IPs Button - Blue background */
    .view-failed-ips {
      background-color: #3CCFFF;        /* Specific background color */
    }

    /* Save Credentials and Collect Data - Inherit default styles */
    .save-credentials,
    .collect-data {
      /* Inherits styles from .action-button */
      /* Add any additional styles here if needed */
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div class="background"></div>
  <div class="top-banner">
    <h1>ECLYPSE Hub</h1>
    <h2>ECLYPSE Controller Datalink Visualization</h2>
  </div>
  
  <div id="loading-screen" aria-live="assertive" role="alert">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
  </div>
  
  <div id="graph-container">
    <svg></svg>
  </div>
  
  <div class="right-panel" id="right-panel">
    <div class="right-panel-content">
      <div class="legend-container">
        <h3>Datalink Node Types</h3>
        <div class="legend">
          <div class="legend-items-container">
            <div class="legend-item">
              <div class="legend-color" style="background-color: #3CCFFF;"></div>
              <span>ECLYPSE</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="bacnet-checkbox" checked>
              <div class="legend-color" style="background-color: #3C8DFF;"></div>
              <span>BACnet</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="modbus-checkbox" checked>
              <div class="legend-color" style="background-color: #FF6F3C;"></div>
              <span>Modbus</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="iot-checkbox" checked>
              <div class="legend-color" style="background-color: #A3FF3C;"></div>
              <span>IoT Connection</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="mqtt-checkbox" checked>
              <div class="legend-color" style="background-color: #3CFFB5;"></div>
              <span>MQTT Broker</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="weather-checkbox" checked>
              <div class="legend-color" style="background-color: #3250a8;"></div>
              <span>Weather Service</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="email-checkbox" checked>
              <div class="legend-color" style="background-color: #FF3C7E;"></div>
              <span>Email Server</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="ntp-checkbox" checked>
              <div class="legend-color" style="background-color: #FFD23C;"></div>
              <span>NTP Time Server</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="internet-checkbox" checked>
              <div class="legend-color" style="background-color: #FF7F50;"></div>
              <span>Internet Connectivity</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="bbmd-checkbox" checked>
              <div class="legend-color" style="background-color: #C39BFF;"></div>
              <span>BBMD</span>
            </div>
            <div class="legend-item">
              <input type="checkbox" id="tunnel-checkbox" checked>
              <div class="legend-color" style="background-color: #40E0D0;"></div>
              <span>Remote Tunnel Connection</span>
            </div>
          </div>
        </div>
        <h3>Configuration</h3>
        <!-- Configuration Container -->
        <div class="configuration-container">
          <!-- Auto Zoom Checkbox -->
          <div class="checkbox-container">
            <input type="checkbox" id="autoZoom" name="autoZoom">
            <label for="autoZoom">Auto Zoom</label>
          </div>

          <!-- Save Credentials Form -->
          <form id="credentials-form">
            <label for="username-input">
              <span class="tooltip-text">Enter Username</span>
              Username
            </label>
            <input type="text" id="username-input" name="username-input" required>
            
            <label for="password-input">
              <span class="tooltip-text">Enter Password</span>
              Password
            </label>
            <input type="password" id="password-input" name="password-input" required>
            
            <button type="submit" class="action-button save-credentials">Save Credentials</button>
          </form>

          <!-- Collect Data Form -->
          <form id="ip-form">
            <label for="ip-input">
              <span class="tooltip-text">Enter IP Addresses (comma-separated or range)</span>
              IP Addresses
            </label>
            <input type="text" id="ip-input" name="ip-input" required>
            
            <button type="submit" class="action-button collect-data">Collect Data</button>
          </form>

          <!-- View Failed IPs Button -->
          <button id="view-failed-ips" class="action-button view-failed-ips" aria-label="View Failed IPs">
            View Failed IPs (<span id="failed-ip-count">0</span>)
          </button>

          <!-- Clear Failed IPs Button -->
          <button id="clear-failed-ips" class="action-button clear-failed-ips" aria-label="Clear Failed IPs">
            Clear Failed IPs
          </button>

          <!-- Dropdown Menu -->
          <div class="dropdown-container">
            <select id="view-select" class="dropdown-select">
              <option value="gfx-bacnet">GFX Network Values</option>
              <option value="all-bacnet" selected>All Connections</option>
            </select>
          </div>
        </div>
      </div>
      <button class="toggle-button" id="toggle-right-panel"></button>
    </div>
    <div class="side-panel" id="side-panel">
      <div class="side-panel-content">
        <h2>Link MetaData</h2>
        <div id="link-info"></div>
      </div>
      <button class="side-panel-toggle" id="toggle-side-panel"></button>
    </div>
    <div class="node-tooltip"></div>
    <!-- Failed IPs Modal with ARIA roles -->
    <div id="failed-ips-modal" class="modal" role="dialog" aria-labelledby="failed-ips-title" aria-modal="true">
      <div class="modal-content">
        <span class="close" aria-label="Close">&times;</span>
        <h2 id="failed-ips-title">Failed IPs</h2>
        <ul id="modal-failed-ips-list" class="modal-failed-ips-list">
          <!-- Failed IPs will be dynamically inserted here -->
        </ul>
      </div>
    </div>
    <script>
    console.log("Script loaded successfully.");

    let globalData;
    let nodesSettled = false;
    let currentHighlightedLink = null;
    let hidePanelTimeout;
    let currentClickedLink = null;
    let currentClickedNode = null;
    let links = [];
    let device_username = "";
    let device_password = "";
    let autoZoomEnabled = true;

    var width = window.innerWidth,
        height = window.innerHeight - 80;

    var zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on("zoom", function (event) {
          contentGroup.attr("transform", event.transform);
        });

    var svg = d3.select("#graph-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(zoom);

    svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all");

    var contentGroup = svg.append("g");

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.id).distance(50).strength(0.5))
        .force("charge", d3.forceManyBody().strength(-35))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => calculateCollisionRadius(d, 250))) // Increase collision radius
        .alpha(0.8) // Set a lower initial alpha value
        .alphaDecay(0.03) // Set a lower alpha decay rate
        .velocityDecay(0.8); // Set a higher velocity decay rate

    const rightPanel = document.getElementById("right-panel");
    const toggleButton = document.getElementById("toggle-right-panel");
    const onlineColor = "#66ff00";
    const offlineColor = "gray";
    const viewSelect = document.getElementById("view-select");

    simulation.on("end", () => {
      nodesSettled = true;
      zoomFit();
    });

    d3.select("#side-panel")
      .on("mouseover", function () {
        clearTimeout(hidePanelTimeout);
      });

    // Select modal elements
    const failedIpsModal = document.getElementById('failed-ips-modal');
    const viewFailedIpsButton = document.getElementById('view-failed-ips');
    const closeModalSpan = failedIpsModal.querySelector('.close');

    // Show the modal when the "View Failed IPs" button is clicked
    viewFailedIpsButton.addEventListener('click', function() {
      failedIpsModal.classList.add('show');
      failedIpsModal.querySelector('.close').focus();
    });

    // Hide the modal when the close button is clicked
    closeModalSpan.addEventListener('click', function() {
      failedIpsModal.classList.remove('show');
      viewFailedIpsButton.focus();
    });

    // Hide the modal when clicking outside of the modal content
    window.addEventListener('click', function(event) {
      if (event.target === failedIpsModal) {
        failedIpsModal.classList.remove('show');
        viewFailedIpsButton.focus();
      }
    });
    
    document.addEventListener('DOMContentLoaded', function () {
      const viewSelect = document.getElementById("view-select");

      // Show the loading screen if a fetch is already in progress
      const isLoading = localStorage.getItem('is_loading') === 'true';
      if (isLoading) {
        document.getElementById('loading-screen').style.display = 'flex';
      }

      const storedIPAddresses = localStorage.getItem('ip_addresses');
      const storedUsername = localStorage.getItem('username');
      const storedPassword = localStorage.getItem('password');
      
      if (storedIPAddresses && storedUsername && storedPassword) {
        device_username = storedUsername;
        device_password = storedPassword;
        document.getElementById('username-input').value = storedUsername;
        document.getElementById('password-input').value = storedPassword;
        document.getElementById('ip-input').value = storedIPAddresses;
        
        // **Before Starting Fetch**
        localStorage.setItem('is_loading', 'true');
        document.getElementById('loading-screen').style.display = 'flex';
        
        fetch('/api/data', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ ip_addresses: storedIPAddresses, username: storedUsername, password: storedPassword })
        })
          .then(response => {
            console.log("Received response from /api/data:", response); // Debugging log
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            try {
              console.log("Fetched data:", data); // Debugging log
              loadDataAndUpdateGraph(data);
              
              // Store failed IPs
              const failedIPs = data.failed_ips || [];
              console.log("Failed IPs to store:", failedIPs); // Debugging log
              localStorage.setItem('failed_ips', JSON.stringify(failedIPs));
              
              // Display failed IPs
              displayFailedIPs();
              
              // **After Fetch Completes**
              localStorage.setItem('is_loading', 'false');
              document.getElementById('loading-screen').style.display = 'none';
            } catch (error) {
              console.error("Error during loadDataAndUpdateGraph or displayFailedIPs:", error);
            }
          })
          .catch(error => {
            console.error('Fetch Error:', error);
            
            // **After Fetch Fails**
            localStorage.setItem('is_loading', 'false');
            document.getElementById('loading-screen').style.display = 'none';
            
            // Optionally, display an error message to the user
            alert('Failed to load data. Please try again.');
            
            // Optionally, clear failed IPs on error
            localStorage.setItem('failed_ips', JSON.stringify([]));
            console.log('Clearing IPs on Error');
            displayFailedIPs();
          });
      } else {
        // Hide the loading screen if no data is being fetched
        document.getElementById('loading-screen').style.display = 'none';
      }
      
      const storedAutoZoomState = localStorage.getItem('autoZoomEnabled');
      if (storedAutoZoomState !== null) {
        autoZoomEnabled = storedAutoZoomState === 'true';
        document.getElementById('auto-zoom-checkbox').checked = autoZoomEnabled;
      } else {
        autoZoomEnabled = true; // Default to true if no stored value
      }
    });

    function applyStoredCheckboxStates() {
      const checkboxes = [
        { id: 'bacnet-checkbox', nodeType: 'bacnet_remote' },
        { id: 'modbus-checkbox', nodeType: 'modbus_remote' },
        { id: 'iot-checkbox', nodeType: 'iot_remote' },
        { id: 'mqtt-checkbox', nodeType: 'mqtt_remote' },
        { id: 'weather-checkbox', nodeType: 'weather_remote' },
        { id: 'email-checkbox', nodeType: 'email_remote' },
        { id: 'ntp-checkbox', nodeType: 'ntp_remote' },
        { id: 'internet-checkbox', nodeType: 'internet_remote' },
        { id: 'bbmd-checkbox', nodeType: 'bbmd_primary' },
        { id: 'tunnel-checkbox', nodeType: 'rmt_remote' }
      ];

      checkboxes.forEach(({ id, nodeType }) => {
        const checkbox = document.getElementById(id);
        const storedState = localStorage.getItem(nodeType + '-visibility');
        if (storedState !== null) {
          checkbox.checked = storedState === 'true';
        } else {
          // If no stored state, default to checked
          checkbox.checked = true;
        }
        toggleNodesAndLinks(nodeType, checkbox.checked);
      });
    }

    function isConnected(node1, node2) {
      return simulation.force("link").links().some(function(link) {
        return (link.source === node1 && link.target === node2) || (link.source === node2 && link.target === node1);
      });
    }

    function countVisibleNodes() {
      return d3.selectAll(".node:not(.node-hidden)").size();
    }

    function updateSimulation(visibleNodes) {
      simulation
        .force("link", d3.forceLink().id(d => d.id).distance(50).strength(0.5))
        .force("charge", d3.forceManyBody().strength(-35))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => calculateCollisionRadius(d, 250))) // Increase collision radius
        .alpha(0.8) // Set a lower initial alpha value
        .alphaDecay(0.03) // Set a lower alpha decay rate
        .velocityDecay(0.8); // Set a higher velocity decay rate
    }

    function calculateCollisionRadius(d, minDistance) {
      const nodeSize = calculateNodeSize(d);
      return nodeSize + minDistance;
    }

    function updateGraph() {
      const visibleNodes = countVisibleNodes();
      updateSimulation(visibleNodes);
      updateZoom(visibleNodes);

      // Restart the simulation
      simulation.alpha(1).restart();
    }

    function updateZoom(visibleNodes) {
      zoom
        .scaleExtent([0.1, 10 / Math.sqrt(visibleNodes)])
        .on("zoom", function (event) {
          contentGroup.attr("transform", event.transform);
        });

      svg.call(zoom);
    }

    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
      d.dragging = true; // Set a flag to indicate dragging
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = Math.max(-10000, event.y); // Restrict dragging below the banner
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
      d.dragging = false; // Reset the dragging flag
      if (currentClickedNode) {
        fadeUnconnectedNodes(currentClickedNode, simulation.force("link").links());
      } else {
        resetNodeOpacity(); // Reset the opacity of all nodes
      }
    }

    function hasLinks(nodeId, links) {
      return links.some(link => link.source.id === nodeId || link.target.id === nodeId);
    }

    function generateTooltipContent(nodeData) {
      let tooltipContent = '';

      if (nodeData.id) {
        tooltipContent += `<div>ID: ${nodeData.id}</div>`;
      }
      if (nodeData.description && nodeData["node-type"] !== "internet_remote") {
        tooltipContent += `<div>Description: ${nodeData.description}</div>`;
      }
      if (nodeData["ip-address"]) {
        tooltipContent += `<div>IP Address: ${nodeData["ip-address"]}</div>`;
      }
      if (nodeData.location) {
        tooltipContent += `<div>Location: ${nodeData.location}</div>`;
      }
      if (
        nodeData["model-name"] &&
        (nodeData["node-type"] === "bacnet_local" ||
          nodeData["node-type"] === "bacnet_remote" ||
          nodeData["node-type"] === "modbus_remote")
      ) {
        tooltipContent += `<div>Model Name: ${nodeData["model-name"]}</div>`;
      }
      if (nodeData["node-type"]) {
        let nodeType = '';
        if (nodeData["node-type"] === "bacnet_local") {
          nodeType = "ECLYPSE";
        } else if (nodeData["node-type"] === "bacnet_remote") {
          nodeType = "BACNet";
        } else if (nodeData["node-type"] === "modbus_remote") {
          nodeType = "Modbus";
        } else if (nodeData["node-type"] === "weather_remote") {
          nodeType = "Weather Service";
        } else if (nodeData["node-type"] === "iot_remote") {
          nodeType = "Azure IOT Hub";
        } else if (nodeData["node-type"] === "email_remote") {
          nodeType = "SMTP Email Server";
        } else if (nodeData["node-type"] === "mqtt_remote") {
          nodeType = "MQTT Broker";
        } else if (nodeData["node-type"] === "internet_remote") {
          nodeType = "Internet Connectivity";
        } else if (nodeData["node-type"] === "ntp_remote") {
          nodeType = "NTP Time Server";
        } else if (nodeData["node-type"] === "rmt_remote") {
          nodeType = "Remote Tunnel Connection";
        }
        if (
          nodeData["node-type"] === "bacnet_local" ||
          nodeData["node-type"] === "bacnet_remote" ||
          nodeData["node-type"] === "modbus_remote"
        ) {
          tooltipContent += `<div>Node Type: ${nodeType}</div>`;
        }
      }
      if (nodeData["object-name"]) {
        tooltipContent += `<div>Object Name: ${nodeData["object-name"]}</div>`;
      }
      if (nodeData.provider && nodeData["node-type"] !== "weather_remote") {
        tooltipContent += `<div>Provider: ${nodeData.provider}</div>`;
      }
      if (nodeData["public-ip"] && nodeData["node-type"] !== "internet_remote") {
        tooltipContent += `<div>Public IP: ${nodeData["public-ip"]}</div>`;
      }
      if (nodeData["active-server"] && nodeData["node-type"] !== "ntp_remote") {
        tooltipContent += `<div>Active Server: ${nodeData["active-server"]}</div>`;
      }
      if (nodeData.enabled !== undefined && nodeData["node-type"] !== "weather_remote" && nodeData["node-type"] !== "ntp_remote") {
        tooltipContent += `<div>Enabled: ${nodeData.enabled ? 'Yes' : 'No'}</div>`;
      }
      if (nodeData["last-success"] && nodeData["node-type"] !== "weather_remote") {
        tooltipContent += `<div>Last Success: ${nodeData["last-success"]}</div>`;
      }

      return tooltipContent;
    }

    function showTooltip(event, d) {
      const tooltip = d3.select(".node-tooltip");
      tooltip.transition()
        .duration(200)
        .style("opacity", .9);

      const tooltipContent = generateTooltipContent(d);

      tooltip.html(tooltipContent)
        .style("left", (event.pageX) + "px")
        .style("top", (event.pageY - 28) + "px");

      // Find all connected nodes using BFS
      const hoveredNode = d;
      const connectedNodes = new Set();
      const queue = [hoveredNode];

      while (queue.length > 0) {
        const node = queue.shift();
        connectedNodes.add(node);

        simulation.force("link").links().forEach(function(link) {
          if (link.source === node && !connectedNodes.has(link.target)) {
            queue.push(link.target);
          } else if (link.target === node && !connectedNodes.has(link.source)) {
            queue.push(link.source);
          }
        });
      }

      d3.selectAll(".node")
        .classed("node-faded", function(d) {
          return !connectedNodes.has(d);
        });
    }

    function hideTooltip() {
      const tooltip = d3.select(".node-tooltip");
      tooltip.transition()
        .duration(500)
        .style("opacity", 0);

      // Remove the node-faded class from all nodes
      d3.selectAll(".node")
        .classed("node-faded", false);
    }

    function resetLinkColors() {
      d3.selectAll(".link-visible").style("stroke", function(d) {
        const targetNode = d.target;
        const sourceNode = d.source;
        const linkData = findLinkData(sourceNode, targetNode);
        const value = linkData ? linkData["Connection-Status"] || linkData["Enabled"] : undefined;
        return value === "Online" || value === "True" ? onlineColor : offlineColor;
      });
    }

    function hideSidePanel() {
      const sidePanel = document.getElementById("side-panel");
      sidePanel.classList.remove("show");

      if (currentClickedLink) {
        d3.select(currentClickedLink.linkElement).style("stroke", null);
        currentClickedLink = null;
      }

      resetLinkColors();
    }

    const nodeTypeDataMap = {
      "modbus_remote": ["points"],
      "bacnet_remote": ["objects"],
      "iot_remote": ["Status", "Last-Update", "Device-ID"], // Update with actual fields
      "mqtt_remote": ["Topic", "QoS", "Last Message"], // Update with actual fields
      "weather_remote": ["Enabled", "Last-Success"], // Ensure these match actual data fields
      "email_remote": ["Enabled", "Hostname"], // Ensure these match actual data fields
      "ntp_remote": ["Active-Server", "Enabled", "Fallback-Servers", "System-Servers"],
      "internet_remote": ["Public-Ip"], // Specific field for Internet Connection
      "rmt_remote": ["Tunnels"], // Replace with actual field names if different
      "bbmd_primary": ["bbmdData"] // Replace with actual field names if different
      // Add more mappings as necessary
    };

    function showSidePanel(event, d) {
      const sidePanel = document.getElementById("side-panel");
      sidePanel.classList.add("show");

      const sidePanelContent = d3.select("#link-info");
      sidePanelContent.html("<p>Loading data...</p>"); // Display a loading message

      const sourceNode = d.source;
      const targetNode = d.target;

      const sourceDeviceName = sourceNode["object-name"] || sourceNode["local-name"] || sourceNode.id;
      const targetDeviceName = targetNode["object-name"] || targetNode["local-name"] || targetNode.id;

      // Retrieve and normalize node-type from node data
      const sourceNodeTypeRaw = globalData.Nodes[sourceNode.id] ? globalData.Nodes[sourceNode.id]["node-type"] : "";
      const targetNodeTypeRaw = globalData.Nodes[targetNode.id] ? globalData.Nodes[targetNode.id]["node-type"] : "";

      const sourceNodeType = sourceNodeTypeRaw.toLowerCase().trim();
      const targetNodeType = targetNodeTypeRaw.toLowerCase().trim();
      const selectedView = localStorage.getItem('selectedView') || viewSelect.value;

      // Define bidirectional node types (e.g., ECLYPSE devices)
      const bidirectionalNodeTypes = ["bacnet_local"]; // Add other bidirectional types if necessary

      // Determine if both nodes are bidirectional
      const isBidirectional = bidirectionalNodeTypes.includes(sourceNodeType) && bidirectionalNodeTypes.includes(targetNodeType);

      // **Enhanced Logging**
      console.log("=== Show Side Panel ===");
      console.log(`Source Node ID: ${sourceNode.id} (${sourceNodeType})`);
      console.log(`Target Node ID: ${targetNode.id} (${targetNodeType})`);
      console.log(`Is Bidirectional: ${isBidirectional}`);

      let linkInfo = `
        <div><strong>Source Device:</strong> ${sourceDeviceName}</div>
        <div><strong>Target Device:</strong> ${targetDeviceName}</div>
        <br/>
      `;

      // Determine where to fetch link data from based on view
      let linksData = null;
      if (selectedView === "gfx-bacnet") {
        linksData = globalData.Links["Network Values"];
      } else if (selectedView === "all-bacnet") {
        // Combine both "Network Values" and "Objects" for comprehensive data
        linksData = { ...globalData.Links["Network Values"], ...globalData.Links.Objects };
      }

      const sourceId = sourceNode.id;
      const targetId = targetNode.id;

      if (isBidirectional) {
        // Handle bidirectional data for ECLYPSE devices

        // Retrieve linkData for source to target
        const linkDataSourceToTarget = linksData[sourceId] && linksData[sourceId][targetId] ? linksData[sourceId][targetId] : null;

        // Retrieve linkData for target to source
        const linkDataTargetToSource = linksData[targetId] && linksData[targetId][sourceId] ? linksData[targetId][sourceId] : null;

        // **Enhanced Logging**
        console.log("Link Data Source → Target:", linkDataSourceToTarget);
        console.log("Link Data Target → Source:", linkDataTargetToSource);

        // Initialize arrays to collect objects
        let allObjectsSourceToTarget = [];
        let allObjectsTargetToSource = [];

        // Collect objects from source to target
        if (linkDataSourceToTarget && linkDataSourceToTarget.objects) {
          for (const objectType in linkDataSourceToTarget.objects) {
            for (const objectId in linkDataSourceToTarget.objects[objectType]) {
              const objectName = linkDataSourceToTarget.objects[objectType][objectId]["object-name"];
              allObjectsSourceToTarget.push(objectName || "Unnamed Object");
            }
          }
        }

        // Collect objects from target to source
        if (linkDataTargetToSource && linkDataTargetToSource.objects) {
          for (const objectType in linkDataTargetToSource.objects) {
            for (const objectId in linkDataTargetToSource.objects[objectType]) {
              const objectName = linkDataTargetToSource.objects[objectType][objectId]["object-name"];
              allObjectsTargetToSource.push(objectName || "Unnamed Object");
            }
          }
        }

        // Function to generate HTML for lists
        function generateListHTML(items) {
          if (items.length === 0) return "<li>No data available.</li>";
          return items.map(item => `<li>${item}</li>`).join("");
        }

        // Append Source → Target Data
        linkInfo += `
          <h3>ECLYPSE Data (${sourceDeviceName} → ${targetDeviceName}):</h3>
          <ul>
            ${generateListHTML(allObjectsSourceToTarget)}
          </ul>
        `;
        if (linkDataSourceToTarget && linkDataSourceToTarget["Connection-Status"]) {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="font-family: 'Courier New', monospace; color: #00ff00;">${linkDataSourceToTarget["Connection-Status"]}</span></div><br/>`;
        } else {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="font-family: 'Courier New', monospace; color: #00ff00;">N/A</span></div><br/>`;
        }

        // Append Target → Source Data
        linkInfo += `
          <div><strong>Source Device:</strong> ${targetDeviceName}</div>
          <div><strong>Target Device:</strong> ${sourceDeviceName}</div>
          <br/>
          <h3>ECLYPSE Data (${targetDeviceName} → ${sourceDeviceName}):</h3>
          <ul>
            ${generateListHTML(allObjectsTargetToSource)}
          </ul>
        `;
        if (linkDataTargetToSource && linkDataTargetToSource["Connection-Status"]) {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="font-family: 'Courier New', monospace; color: #00ff00;">${linkDataTargetToSource["Connection-Status"]}</span></div>`;
        } else {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="font-family: 'Courier New', monospace; color: #00ff00;">N/A</span></div>`;
        }

      } else {
        // Handle unidirectional data for all other node types

        // Retrieve linkData in one direction (source to target)
        const linkData = linksData[sourceId] && linksData[sourceId][targetId] ? linksData[sourceId][targetId] : null;

        // **Enhanced Logging**
        console.log("=== Processing Unidirectional Link ===");
        console.log("Link Data Source → Target:", linkData);

        if (!linkData) {
          linkInfo += `<div>No link data available.</div>`;
          sidePanelContent.html(linkInfo);
          return;
        }

        // Initialize arrays to collect data
        let allObjects = [];
        let allPoints = [];
        let allCustomDataItems = []; // For other custom data fields

        // Collect 'objects' if present (e.g., for bacnet_remote)
        if (linkData.objects) {
          for (const objectType in linkData.objects) {
            for (const objectId in linkData.objects[objectType]) {
              const objectName = linkData.objects[objectType][objectId]["object-name"];
              allObjects.push(objectName || "Unnamed Object");
            }
          }
        }

        // Collect 'points' if present (e.g., for modbus_remote)
        if (linkData.points) {
          for (const pointId in linkData.points) {
            const pointName = linkData.points[pointId]["object-name"];
            allPoints.push(pointName || "Unnamed Point");
          }
        }

        // Collect other custom data fields based on nodeTypeDataMap
        const dataFieldsSource = nodeTypeDataMap[sourceNodeType] || [];
        const dataFieldsTarget = nodeTypeDataMap[targetNodeType] || [];

        // Merge data fields, excluding 'points' and 'objects' to prevent duplication
        const customDataFields = [...dataFieldsSource, ...dataFieldsTarget].filter(field => field !== "points" && field !== "objects");

        for (const field of customDataFields) {
          if (linkData[field] !== undefined && linkData[field] !== null) {
            if (typeof linkData[field] === 'object' && !Array.isArray(linkData[field])) {
              // If the field is an object, iterate over its key-value pairs
              for (const key in linkData[field]) {
                const value = linkData[field][key];
                allCustomDataItems.push(`${key}: ${value}`);
              }
            } else {
              // If the field is a primitive or array, display its value
              allCustomDataItems.push(`${field}: ${linkData[field]}`);
            }
          }
        }

        // Function to generate HTML for lists
        function generateListHTML(items) {
          if (items.length === 0) return "<li>No data available.</li>";
          return items.map(item => `<li>${item}</li>`).join("");
        }

        // Determine heading and list based on available data
        let headingText = "";
        let listHTML = "";
        let valueStyle = "font-family: 'Courier New', monospace; color: #00ff00;";

        if (allPoints.length > 0) {
          headingText = "Modbus Points:";
          listHTML = generateListHTML(allPoints);
        } else if (allObjects.length > 0) {
          headingText = "Bacnet Remote Objects:";
          listHTML = generateListHTML(allObjects);
        }

        // Append List-Based Data (objects or points)
        if (listHTML) {
          linkInfo += `
            <h3>${headingText}</h3>
            <ul>
              ${listHTML}
            </ul>
          `;
        }

        // Append Custom Data as Separate Divs
        if (allCustomDataItems.length > 0) {
          linkInfo += `
            <h3>Custom Data:</h3>
          `;
          for (const item of allCustomDataItems) {
            linkInfo += `<div>${item}</div>`;
          }
        }

        // Append Connection Status
        if (linkData["Connection-Status"]) {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="${valueStyle}">${linkData["Connection-Status"]}</span></div>`;
        } else {
          linkInfo += `<div><strong>Connection Status:</strong> <span style="${valueStyle}">No data available.</span></div>`;
        }
      }

      // Finalize the HTML content
      sidePanelContent.html(linkInfo);
    }

    function loadDataAndUpdateGraph(data) {
      try {
        console.log("Loading data into graph:", data); // Debugging log
        globalData = data; // Assign the passed data to globalData

        const viewSelect = document.getElementById("view-select");
        const selectedView = localStorage.getItem('selectedView') || viewSelect.value;

        viewSelect.value = selectedView;

        const nodeMap = new Map();
        const nodesArray = Object.keys(globalData.Nodes).map(id => {
          const node = {
            id: String(id),
            ...globalData.Nodes[id],
            x: width / 2, // Set initial x position to the center
            y: height / 2, // Set initial y position to the center
            vx: 0,
            vy: 0
          };
          nodeMap.set(node.id, node);
          return node;
        });

        if (selectedView === "gfx-bacnet") {
          updateNetworkValuesGraph(globalData.Links["Network Values"], nodesArray, nodeMap);
        } else if (selectedView === "all-bacnet") {
          updateRemoteObjectsGraph(globalData.Links.Objects, nodesArray, nodeMap);
        }

        // Apply stored checkbox states after the graph is loaded
        applyStoredCheckboxStates();
        
        console.log("Graph loaded and updated."); // Debugging log
      } catch (error) {
        console.error("Error in loadDataAndUpdateGraph:", error);
      }
    }
    
    function extractLinks(linksData, nodeMap) {
      const links = [];
      for (const sourceId in linksData) {
        const targets = linksData[sourceId];
        for (const targetId in targets) {
          if (targetId !== 'count') {
            const sourceNode = nodeMap.get(String(sourceId));
            const targetNode = nodeMap.get(targetId);
            if (sourceNode && targetNode) {
              links.push({
                source: sourceNode,
                target: targetNode
              });
            } else {
              console.warn(`Missing node in nodeMap: source=${sourceId}, target=${targetId}`);
            }
          }
        }
      }
      return links;
    }

    function createLinks(links, nodes) {
      const linkGroup = contentGroup.append("g")
        .attr("class", "links");

      const linkVisible = linkGroup.selectAll(".link-visible")
        .data(links)
        .enter()
        .append("line")
        .attr("class", d => {
          const linkData = findLinkData(d.source, d.target);
          const value = linkData ? linkData["Connection-Status"] || linkData["Enabled"] : undefined;
          return `link-visible ${value === "Online" || value === "True" ? "link-online" : "link-offline"}`;
        })
        .attr("id", d => `link-${d.source.id}-${d.target.id}`)
        .style("stroke", d => {
          const linkData = findLinkData(d.source, d.target);
          const value = linkData ? linkData["Connection-Status"] || linkData["Enabled"] : undefined;
          return value === "Online" || value === "True" ? onlineColor : offlineColor;
        })
        .style("stroke-width", 3)
        .style("opacity", 0) // Set initial opacity to 0
        .style("pointer-events", "none") // Ensure no pointer events
        .each(function(d) {
          d.linkElement = this;
        });

      const linkHover = linkGroup.selectAll(".link-hover")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link-hover")
        .style("stroke", "transparent")
        .style("stroke-width", 20)
        .style("opacity", 0) // Set initial opacity to 0
        .on("click", handleLinkClick)
        .style("pointer-events", "auto"); // Enable pointer events for hover

      // Transition link lines to visible after a delay
      setTimeout(() => {
        linkVisible.transition()
          .duration(500)
          .style("opacity", 1);

        linkHover.transition()
          .duration(500)
          .style("opacity", 1);
      }, 800); // Adjust the delay as needed

      simulation.on("tick", () => {
        linkVisible
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        linkHover
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        contentGroup.selectAll(".node")
          .transition() // Add transition
          .duration(200) // Set the duration of the transition
          .ease(d3.easeQuadOut) // Add easing function
          .attr("transform", d => `translate(${d.x},${d.y})`);
      });

      simulation.nodes(nodes);
      simulation.alpha(1).restart();
    }

    function handleNodeMouseOver(event, d, links) {
      if (nodesSettled && !currentClickedNode) {
        showTooltip(event, d);
        fadeUnconnectedNodes(d, links);
      }
    }

    function handleNodeMouseOut(event, d) {
      if (nodesSettled && !currentClickedNode) {
        hideTooltip();
        resetNodeOpacity();
      }
    }

    function handleNodeClick(event, d, links) {
      if (currentClickedNode === d) {
        // Node is already clicked, so reset opacity
        resetNodeOpacity();
        currentClickedNode = null;
      } else {
        // Different node clicked
        resetNodeOpacity(); // Reset any previous opacity changes
        fadeUnconnectedNodes(d, links); // Apply opacity changes
        currentClickedNode = d;
      }
    }

    function fadeUnconnectedNodes(d, links) {
      const hoveredNode = d;
      const connectedNodes = new Set([hoveredNode]);

      links.forEach(function(link) {
        if (link.source.id === hoveredNode.id) {
          connectedNodes.add(link.target);
        } else if (link.target.id === hoveredNode.id) {
          connectedNodes.add(link.source);
        }
      });

      d3.selectAll(".node")
        .transition()
        .duration(0)
        .style("opacity", function(d) {
          const isConnected = connectedNodes.has(d);
          return isConnected ? 1 : 0.2;
        });

      d3.selectAll(".link-visible")
        .transition()
        .duration(0)
        .style("opacity", function(link) {
          const isConnected = link.source === d || link.target === d;
          return isConnected ? 1 : 0.2;
        });
    }

    function resetNodeOpacity() {
      d3.selectAll(".node")
        .transition()
        .duration(0)
        .style("opacity", 1);

      d3.selectAll(".link-visible")
        .transition()
        .duration(0)
        .style("opacity", 1);
    }

    function createBACNetNodes(nodes, links) {
      const nodeGroup = contentGroup.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .on("mouseover", (event, d) => handleNodeMouseOver(event, d, links))
        .on("mouseout", handleNodeMouseOut)
        .on("click", function(event, d) {
          handleNodeClick(event, d, links);
        });

      nodeGroup.append("circle")
        .attr("r", d => calculateNodeSize(d))
        .attr("fill", d => {
          if (d["node-type"] === "bacnet_local") return "#3CCFFF";
          if (d["node-type"] === "bacnet_remote") return "#3C8DFF";
          if (d["node-type"] === "modbus_remote") return "#FF6F3C";
          if (d["node-type"] === "iot_remote") return "#A3FF3C";
          if (d["node-type"] === "mqtt_remote") return "#3CFFB5";
          if (d["node-type"] === "weather_remote") return "#3250a8";
          if (d["node-type"] === "email_remote") return "#FF3C7E";
          if (d["node-type"] === "ntp_remote") return "#FFD23C";
          if (d["node-type"] === "internet_remote") return "#FF7F50";
          if (d["node-type"] === "bbmd_primary") return "#C39BFF";
          if (d["node-type"] === "rmt_remote") return "#40E0D0";
          // Add more conditions for other node types
          return "white"; // Default color for unknown node types
        })
        .style("opacity", 1) // Ensure initial opacity is set to 1
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip);

      nodeGroup.on("mouseout", (event, d) => {
        if (nodesSettled && !d.dragging) {
          handleNodeMouseOut(event, d);
        }
      });

      nodeGroup.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
      );

      const imageGroup = nodeGroup.append("g")
        .attr("transform", d => `translate(0, ${-calculateNodeSize(d) * 0.4})`);

      imageGroup.append("image")
        .attr("xlink:href", d => getImageUrl(d["model-name"], d["node-type"]))
        .attr("width", d => calculateNodeSize(d) * 1)
        .attr("height", d => calculateNodeSize(d) * 1)
        .attr("x", d => -calculateNodeSize(d) * 0.5)
        .attr("y", d => -calculateNodeSize(d) * 0.4);

      const textGroup = nodeGroup.append("g")
        .attr("transform", d => `translate(0, ${calculateNodeSize(d) * 0.5})`);

      textGroup.append("text")
        .attr("text-anchor", "middle")
        .style("font-size", d => Math.min(calculateNodeSize(d, links) * 0.4, 22) + "px")
        .style("font-weight", "900") // Use a numeric value for font-weight
        .text(d => {
          if (d["node-type"] === "rmt_remote") {
            return "Remote Tunnel";
          } else {
            return d["object-name"] || d["local-name"] || d.id;
          }
        });

      return nodeGroup;
    }

    function createModbusNodes(modbusNodes, nodes, nodeMap, links) {
      Object.keys(modbusNodes).forEach(id => {
        if (modbusNodes[id]["node-type"] === "modbus_remote" && !nodeMap.has(id)) {
          const node = {
            id: String(id),
            ...modbusNodes[id],
            x: Math.random() * width,
            y: Math.random() * height,
            vx: 0,
            vy: 0
          };
          nodes.push(node);
          nodeMap.set(node.id, node);
        }
      });

      const nodeGroup = contentGroup.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes.filter(d => d["node-type"] === "modbus_remote"))
        .enter()
        .append("g")
        .attr("class", "node")
        .on("mouseover", (event, d) => handleNodeMouseOver(event, d, links))
        .on("mouseout", handleNodeMouseOut)
        .on("click", function(event, d) {
          handleNodeClick(event, d, links);
        });

      nodeGroup.append("circle")
        .attr("r", d => calculateNodeSize(d))
        .attr("fill", "orange")
        .style("opacity", 1) // Ensure initial opacity is set to 1
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip);

      nodeGroup.on("mouseout", (event, d) => {
        if (nodesSettled && !d.dragging) {
          handleNodeMouseOut(event, d);
        }
      });

      nodeGroup.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
      );


      const imageGroup = nodeGroup.append("g")
        .attr("transform", d => `translate(0, ${-calculateNodeSize(d) * 0.4})`);

      imageGroup.append("image")
        .attr("xlink:href", d => getImageUrl(d["model-name"], d["node-type"]))
        .attr("width", d => calculateNodeSize(d) * 0.8)
        .attr("height", d => calculateNodeSize(d) * 0.8)
        .attr("x", d => -calculateNodeSize(d) * 0.4)
        .attr("y", d => -calculateNodeSize(d) * 0.4);

      const textGroup = nodeGroup.append("g")
        .attr("transform", d => `translate(0, ${calculateNodeSize(d) * 0.5})`);

      textGroup.append("text")
        .attr("text-anchor", "middle")
        .style("font-size", d => Math.min(calculateNodeSize(d, links) * 0.4, 22) + "px")
        .style("font-weight", "900") // Use a numeric value for font-weight
        .text(d => d["object-name"] || d["local-name"] || d.id);

      return nodeGroup;
    }

    function updateNetworkValuesGraph(networkValues, nodes, nodeMap) {
      contentGroup.selectAll("*").remove();
      d3.select("#link-info").html("");

      links = extractLinks(networkValues, nodeMap);

      createLinks(links, nodes);
      simulation.force("link").links(links);

      const bacnetNodesGroup = createBACNetNodes(nodes, links);
      const modbusNodesGroup = createModbusNodes(globalData.Nodes, nodes, nodeMap, links);

      simulation.nodes(nodes);
      simulation.alpha(1).restart();
      updateGraph();
      //setTimeout(zoomFit, 1200);
    }

    function updateRemoteObjectsGraph(remoteObjects, nodes, nodeMap) {
      contentGroup.selectAll("*").remove();
      d3.select("#link-info").html("");

      links = extractLinks(remoteObjects, nodeMap);

      createLinks(links, nodes);
      simulation.force("link").links(links);

      const bacnetNodesGroup = createBACNetNodes(nodes, links);
      const modbusNodesGroup = createModbusNodes(globalData.Nodes, nodes, nodeMap, links);

      simulation.nodes(nodes);
      simulation.alpha(1).restart();
      updateGraph();
      //setTimeout(zoomFit, 1200);
    }

    function zoomFit() {
      if (!autoZoomEnabled) return; // Exit if auto-zoom is disabled
      const visibleNodes = contentGroup.selectAll(".node:not(.node-hidden)").data();
      if (visibleNodes.length === 0) return; // Exit if no visible nodes

      // Calculate the extent of the visible nodes, accounting for node size
      const minX = d3.min(visibleNodes, d => d.x - calculateNodeSize(d));
      const maxX = d3.max(visibleNodes, d => d.x + calculateNodeSize(d));
      const minY = d3.min(visibleNodes, d => d.y - calculateNodeSize(d));
      const maxY = d3.max(visibleNodes, d => d.y + calculateNodeSize(d));

      if (minX === undefined || maxX === undefined || minY === undefined || maxY === undefined) return;

      // Define padding around the nodes
      const padding = 200; // Increased padding to prevent cutoff

      // Calculate the width and height of the bounding box
      const width = maxX - minX;
      const height = maxY - minY;

      // Get SVG dimensions
      const svgWidth = parseInt(svg.attr("width"));
      const svgHeight = parseInt(svg.attr("height"));

      // Avoid division by zero
      if (width === 0 || height === 0) return;

      // Calculate the scale to fit all visible nodes within the SVG, considering padding
      const scale = (0.95 * Math.min(svgWidth / width, svgHeight / height)) / 1; // Adjust numerator as needed

      // Calculate the translation to center the bounding box
      const translate = [
        svgWidth / 2 - scale * (minX + width / 2),
        svgHeight / 2 - scale * (minY + height / 2)
      ];

      // Optional: Limit the scale to prevent excessive zooming
      const maxScale = 5;
      const minScale = 0.1;
      const adjustedScale = Math.min(Math.max(scale, minScale), maxScale);

      // Apply the zoom transformation
      svg.transition()
        .duration(750)
        .call(
          zoom.transform,
          d3.zoomIdentity
            .translate(translate[0], translate[1])
            .scale(adjustedScale)
        );
    }
    
    function calculateNodeSize(d) {
      const minSize = 125; // Minimum size of the node
      const maxSize = 225; // Maximum size of the node
      const linkCount = simulation.force("link").links().filter(link => link.source.id === d.id || link.target.id === d.id).length;
      return Math.min(minSize + (linkCount * 5), maxSize); // Increase size based on the number of links, up to a maximum size
    }

    function getImageUrl(modelName, nodeType) {
      const defaultBACnetImage = "static/images/BacnetGeneric.png";
      const defaultModbusImage = "static/images/ModbusGeneric.png";

      // Hardcoded mapping between model names and their specific images
      const modelImageMap = {
        "ECB_203": "static/images/ECB_203.png",
        "ECB_253": "static/images/ECB_253.png",
        "ECB_300": "static/images/ECB_300.png",
        "ECB_350": "static/images/ECB_350.png",
        "ECB_400": "static/images/ECB_400.png",
        "ECB_403": "static/images/ECB_403.png",
        "ECB_450": "static/images/ECB_450.png",
        "ECB_453": "static/images/ECB_453.png",
        "ECB_600": "static/images/ECB_600.png",
        "ECB_650": "static/images/ECB_650.png",
        "ECB_VAV": "static/images/ECB_VAV.png",
        "ECY-VAV": "static/images/ECY-VAV-BI.png",
        "ECY-VAV-BI": "static/images/ECY-VAV-BI.png",
        "ECY-PTU-107-BI": "static/images/ECY-PTU-107-BI.png",
        "ECY-PTU-107": "static/images/ECY-PTU-107-BI.png",
        "ECY-TU203-BI": "static/images/ECY-TU203-BI.png",
        "ECY-TU203": "static/images/ECY-TU203-BI.png",
        "ECY-PTU-207-BI": "static/images/ECY-PTU-207-BI.png",
        "ECY-PTU-207": "static/images/ECY-PTU-207-BI.png",
        "ECY-PTU-208-BI": "static/images/ECY-PTU-208-BI.png",
        "ECY-PTU-208": "static/images/ECY-PTU-208-BI.png",
        "ECY-303": "static/images/ECY-303-BI.png",
        "ECY-303-BI": "static/images/ECY-303-BI.png",
        "ECY-400-BI": "static/images/ECY-400-BI.png",
        "ECY-450-BI": "static/images/ECY-450-BI.png",
        "ECY-600-BI": "static/images/ECY-600-BI.png",
        "ECY-650-BI": "static/images/ECY-650-BI.png",
        "ECY-APEX": "static/images/ECY-APEX-BI.png",
        "ECY-S1000": "static/images/ECY-S1000-BI.png",
        "ECY-S1000-BI": "static/images/ECY-S1000-BI.png",
        "HORYZON-C": "static/images/HORYZON-C-BI.png",
        "HORYZON-C-BI": "static/images/HORYZON-C-BI.png",
        "ECY-APEX-BI": "static/images/ECY-APEX-BI.png",
        "ECY-APEX": "static/images/ECY-APEX-BI.png",
        "ECY-RM-BI": "static/images/ECY-RM-BI.png",
        "ECY-STAT-R Rev 0.0A": "static/images/ECY-STAT-R Rev 0.0A.png",
        "ECY-STAT-R-BI": "static/images/ECY-STAT-R-BI.png",
        "KE2IN.BN.DV.J4": "static/images/KE2IN.BN.DV.J4.png",
        "KE2IN.BN.GW": "static/images/KE2IN.BN.GW.png",
        "weather_server": "static/images/weather_server.png",
        "iot_hub": "static/images/iot_hub.png",
        "email_server": "static/images/email_server.png",
        "mqtt_broker": "static/images/mqtt_broker.png",
        "internet_server": "static/images/internet_server.png",
        "time_server": "static/images/time_server.png",
        "rmt_tunnel": "static/images/rmt_tunnel.png",
        "Niagara4 Station": "static/images/niagara_station.png",
        // Add more model mappings as needed
      };

      // Check if the modelName exists in the mapping
      if (modelName && modelImageMap.hasOwnProperty(modelName)) {
        return modelImageMap[modelName];
      } else {
        // Return the default image based on nodeType
        return nodeType === "modbus_remote" ? defaultModbusImage : defaultBACnetImage;
      }
    }

    function handleLinkClick(event, d) {
      if (currentClickedLink === d) {
        // If the clicked link is the same as the currently open link, close the side panel and reset the link color
        hideSidePanel();
        resetLinkColor(d);
        currentClickedLink = null;
      } else {
        // If a different link is clicked, update the side panel content, reset the color of the previous link, and set the color of the new link
        if (currentClickedLink) {
          resetLinkColor(currentClickedLink);
        }
        d3.select(d.linkElement).style("stroke", "red");
        showSidePanel(event, d);
        currentClickedLink = d;
      }
    }

    function resetLinkColor(d) {
      const targetNode = d.target;
      const sourceNode = d.source;
      const linkData = findLinkData(sourceNode, targetNode);
      const value = linkData ? linkData["Connection-Status"] || linkData["Enabled"] : undefined;
      console.log("Link Value:", value);

      d3.select(d.linkElement)
        .style("stroke", value === "Online" || value === "True" ? onlineColor : offlineColor);
    }

    function getKeyForNodeType(nodeType) {
      switch (nodeType) {
        case "internet_remote":
          return "Connection-Status";
        case "mqtt_remote":
          return "Connection-Status";
        case "weather_remote":
          return "Connection-Status";
        case "iot_remote":
          return "Connection-Status";
        case "email_remote":
          return "Enabled";
        case "ntp_remote":
          return "Connection-Status";
        case "rmt_remote":
          return "Connection-Status";
        case "bbmd_primary":
          return "Enabled";
        case "bacnet_remote":
          return "Connection-Status";
        case "modbus_remote":
          return "Connection-Status";
        case "bacnet_local":
          return "Connection-Status";
        default:
          return "Connection-Status";
      }
    }

    function findLinkData(sourceNode, targetNode) {
      const sourceId = sourceNode.id;
      const targetId = targetNode.id;

      // Prioritize "Network Values" over "Objects"
      if (globalData.Links["Network Values"][sourceId] && globalData.Links["Network Values"][sourceId][targetId]) {
        return globalData.Links["Network Values"][sourceId][targetId];
      }

      // Then check "Objects"
      if (globalData.Links.Objects[sourceId] && globalData.Links.Objects[sourceId][targetId]) {
        return globalData.Links.Objects[sourceId][targetId];
      }

      // If no link data is found, return null
      return null;
    }

    function toggleNodesAndLinks(nodeType, visible) {
      // Hide or show nodes based on the nodeType and visibility
      d3.selectAll('.node')
        .filter(d => d['node-type'] === nodeType)
        .classed('node-hidden', !visible);

      // Define BACnet-related node types
      const bacnetNodeTypes = ['bacnet_remote', 'bacnet_local'];

      // Hide or show links based on the nodeType and visibility
      d3.selectAll('.link-visible, .link-hover') // Select both link-visible and link-hover
        .filter(function(d) {
          if (nodeType === 'bacnet_remote') {
            // When toggling bacnet_remote, hide links connected to bacnet_remote nodes
            // Do NOT hide links between two bacnet_local nodes (ECLYPSE nodes)
            return (
              d.source['node-type'] === 'bacnet_remote' ||
              d.target['node-type'] === 'bacnet_remote'
            );
          } else {
            // For other node types, hide links connected to the specific nodeType
            return d.source['node-type'] === nodeType || d.target['node-type'] === nodeType;
          }
        })
        .classed('link-hidden', !visible); // Apply or remove the 'link-hidden' class

      // Store the visibility state in localStorage
      localStorage.setItem(nodeType + '-visibility', visible);
    }

    function displayFailedIPs() {
      const failedIPs = JSON.parse(localStorage.getItem('failed_ips')) || [];
      console.log("Displaying Failed IPs:", failedIPs); // Debugging log
      const failedIPCount = failedIPs.length;
      const failedIpCountSpan = document.getElementById('failed-ip-count');
      const viewFailedIpsButton = document.getElementById('view-failed-ips');
      
      // Update the failed IP count
      failedIpCountSpan.textContent = failedIPCount;
      
      // Enable or disable the view button based on the count
      if (failedIPCount > 0) {
        viewFailedIpsButton.disabled = false;
        viewFailedIpsButton.style.opacity = 1;
        viewFailedIpsButton.style.cursor = 'pointer';
      } else {
        viewFailedIpsButton.disabled = true;
        viewFailedIpsButton.style.opacity = 0.5;
        viewFailedIpsButton.style.cursor = 'not-allowed';
      }
      
      // Populate the modal with failed IPs
      const modalFailedIpsList = document.getElementById('modal-failed-ips-list');
      modalFailedIpsList.innerHTML = ''; // Clear existing list
      
      if (failedIPCount === 0) {
        modalFailedIpsList.innerHTML = '<li>No failed IPs.</li>';
      } else {
        failedIPs.forEach(ip => {
          const li = document.createElement('li');
          li.textContent = ip;
          modalFailedIpsList.appendChild(li);
        });
      }
      
      console.log("Failed IPs prepared for modal."); // Debugging log
    }

    document.getElementById('credentials-form').addEventListener('submit', function(event) {
      event.preventDefault();
      device_username = document.getElementById('username-input').value;
      device_password = document.getElementById('password-input').value;
      document.getElementById('username-input').value = "";
      document.getElementById('password-input').value = "";
    });

    document.getElementById('ip-form').addEventListener('submit', function(event) {
      event.preventDefault();
      const ipInput = document.getElementById('ip-input').value;
      
      // **Before Starting Fetch**
      localStorage.setItem('is_loading', 'true');
      document.getElementById('loading-screen').style.display = 'flex';
      
      localStorage.setItem('ip_addresses', ipInput);
      localStorage.setItem('username', device_username);
      localStorage.setItem('password', device_password);
      
      fetch('/api/data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ ip_addresses: ipInput, username: device_username, password: device_password })
      })
        .then(response => response.json())
        .then(data => {
          loadDataAndUpdateGraph(data);
          
          // Store failed IPs
          const failedIPs = data.failed_ips || [];
          console.log("Failed IPs to store:", failedIPs); // Debugging log
          localStorage.setItem('failed_ips', JSON.stringify(failedIPs));
          
          // Display failed IPs
          displayFailedIPs();
          
          // **After Fetch Completes**
          localStorage.setItem('is_loading', 'false');
          document.getElementById('loading-screen').style.display = 'none';
        })
        .catch(error => {
          console.error('Error:', error);
          
          // **After Fetch Fails**
          localStorage.setItem('is_loading', 'false');
          document.getElementById('loading-screen').style.display = 'none';
          
          // Optionally, display an error message to the user
          alert('Failed to load data. Please try again.');
          
          // Optionally, clear failed IPs on error
          localStorage.setItem('failed_ips', JSON.stringify([]));
          displayFailedIPs();
        });
    });

    document.getElementById('clear-failed-ips').addEventListener('click', function() {
      localStorage.setItem('failed_ips', JSON.stringify([]));
      displayFailedIPs();
    });

    const checkboxIds = [
      'bacnet-checkbox',
      'modbus-checkbox',
      'iot-checkbox',
      'mqtt-checkbox',
      'weather-checkbox',
      'email-checkbox',
      'ntp-checkbox',
      'internet-checkbox',
      'bbmd-checkbox',
      'tunnel-checkbox'
    ];

    checkboxIds.forEach(id => {
      document.getElementById(id).addEventListener('change', function() {
        const nodeTypeMap = {
          'bacnet-checkbox': 'bacnet_remote',
          'modbus-checkbox': 'modbus_remote',
          'iot-checkbox': 'iot_remote',
          'mqtt-checkbox': 'mqtt_remote',
          'weather-checkbox': 'weather_remote',
          'email-checkbox': 'email_remote',
          'ntp-checkbox': 'ntp_remote',
          'internet-checkbox': 'internet_remote',
          'bbmd-checkbox': 'bbmd_primary',
          'tunnel-checkbox': 'rmt_remote'
        };
        const nodeType = nodeTypeMap[id];
        const checked = this.checked;
        toggleNodesAndLinks(nodeType, checked);
        
        // After toggling, re-apply zoom to fit visible nodes
        zoomFit();
      });
    });

    document.getElementById("toggle-side-panel").addEventListener("click", function () {
      const sidePanel = document.getElementById("side-panel");
      sidePanel.classList.toggle("show");

      if (!sidePanel.classList.contains("show")) {
        hideSidePanel();
      }
    });

    toggleButton.addEventListener("click", function () {
      rightPanel.classList.toggle("collapsed");
    });
    
    window.addEventListener('resize', () => {
      // Update width and height based on the new window size
      width = window.innerWidth;
      height = window.innerHeight - 80; // Adjust if necessary based on your layout

      // Update the SVG dimensions
      svg.attr("width", width).attr("height", height);

      // Update the simulation's center force
      simulation.force("center", d3.forceCenter(width / 2, height / 2));

      // Restart the simulation to apply the new center force
      simulation.alpha(1).restart();

      // Adjust the zoom to fit the visible nodes
      zoomFit();
    });

    document.getElementById('auto-zoom-checkbox').addEventListener('change', function() {
      autoZoomEnabled = this.checked;
      localStorage.setItem('autoZoomEnabled', autoZoomEnabled); // Optional: store in localStorage

      if (autoZoomEnabled) {
        zoomFit(); // Optionally call zoomFit() immediately when enabling auto-zoom
      }
    });

  </script>
</body>
</html>